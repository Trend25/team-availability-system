<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Suite - Team Availability System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #2d2d2d;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            padding: 30px;
            background: #242424;
        }

        .stat-box {
            text-align: center;
            padding: 20px;
            background: #2d2d2d;
            border-radius: 8px;
            border: 2px solid #3d3d3d;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-value.passed { color: #4CAF50; }
        .stat-value.failed { color: #f44336; }
        .stat-value.skipped { color: #ff9800; }

        .stat-label {
            font-size: 0.9rem;
            color: #999;
            text-transform: uppercase;
        }

        .test-controls {
            padding: 20px 30px;
            background: #242424;
            border-top: 1px solid #3d3d3d;
            display: flex;
            gap: 15px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-run {
            background: #4CAF50;
            color: white;
        }

        .btn-run:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-clear {
            background: #f44336;
            color: white;
        }

        .test-section {
            padding: 30px;
        }

        .test-group {
            margin-bottom: 30px;
            background: #242424;
            border-radius: 8px;
            overflow: hidden;
        }

        .test-group-header {
            background: #333;
            padding: 15px 20px;
            font-weight: 600;
            font-size: 1.1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .test-group-header:hover {
            background: #3d3d3d;
        }

        .test-group-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .badge-pending { background: #555; color: #ccc; }
        .badge-running { background: #ff9800; color: white; }
        .badge-passed { background: #4CAF50; color: white; }
        .badge-failed { background: #f44336; color: white; }

        .test-group-body {
            padding: 20px;
        }

        .test-case {
            padding: 12px 15px;
            margin-bottom: 10px;
            background: #2d2d2d;
            border-radius: 6px;
            border-left: 4px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .test-case.passed {
            border-left-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .test-case.failed {
            border-left-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        .test-case.skipped {
            border-left-color: #ff9800;
            background: rgba(255, 152, 0, 0.1);
            opacity: 0.7;
        }

        .test-name {
            flex: 1;
        }

        .test-status {
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .status-passed {
            background: #4CAF50;
            color: white;
        }

        .status-failed {
            background: #f44336;
            color: white;
        }

        .status-skipped {
            background: #ff9800;
            color: white;
        }

        .test-duration {
            margin-left: 15px;
            color: #999;
            font-size: 0.85rem;
        }

        .test-error {
            margin-top: 10px;
            padding: 10px;
            background: rgba(244, 67, 54, 0.2);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #ff8a80;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #1a1a1a;
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50 0%, #8BC34A 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Test Suite</h1>
            <p>Team Availability System v2.0</p>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-value" id="totalTests">0</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-box">
                <div class="stat-value passed" id="passedTests">0</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-box">
                <div class="stat-value failed" id="failedTests">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-box">
                <div class="stat-value skipped" id="skippedTests">0</div>
                <div class="stat-label">Skipped</div>
            </div>
        </div>

        <div class="test-controls">
            <button class="btn btn-run" onclick="runAllTests()">Run All Tests</button>
            <button class="btn btn-clear" onclick="clearResults()">Clear Results</button>
        </div>

        <div class="test-section" id="testResults">
            <!-- Test groups will be rendered here -->
        </div>
    </div>

    <script>
        // Test Framework
        class TestSuite {
            constructor() {
                this.tests = {};
                this.results = {
                    total: 0,
                    passed: 0,
                    failed: 0,
                    skipped: 0
                };
            }

            group(name) {
                if (!this.tests[name]) {
                    this.tests[name] = [];
                }
                return {
                    test: (testName, fn) => {
                        this.tests[name].push({ name: testName, fn: fn });
                    }
                };
            }

            async runAll() {
                this.results = { total: 0, passed: 0, failed: 0, skipped: 0 };
                const resultsDiv = document.getElementById('testResults');
                resultsDiv.innerHTML = '';

                for (const [groupName, tests] of Object.entries(this.tests)) {
                    const groupDiv = await this.renderGroup(groupName, tests);
                    resultsDiv.appendChild(groupDiv);
                }

                this.updateStats();
            }

            async renderGroup(groupName, tests) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'test-group';

                const header = document.createElement('div');
                header.className = 'test-group-header';
                header.innerHTML = `
                    <span>${groupName}</span>
                    <span class="test-group-badge badge-running" id="badge-${groupName}">Running...</span>
                `;
                groupDiv.appendChild(header);

                const body = document.createElement('div');
                body.className = 'test-group-body';
                groupDiv.appendChild(body);

                let groupPassed = 0;
                let groupFailed = 0;

                for (const test of tests) {
                    this.results.total++;
                    const testDiv = await this.runTest(test);
                    body.appendChild(testDiv);

                    if (testDiv.classList.contains('passed')) groupPassed++;
                    if (testDiv.classList.contains('failed')) groupFailed++;

                    this.updateStats();
                    await this.sleep(100); // Visual delay
                }

                const badge = document.getElementById(`badge-${groupName}`);
                if (groupFailed === 0) {
                    badge.className = 'test-group-badge badge-passed';
                    badge.textContent = `✓ ${groupPassed}/${tests.length}`;
                } else {
                    badge.className = 'test-group-badge badge-failed';
                    badge.textContent = `✗ ${groupFailed} failed`;
                }

                return groupDiv;
            }

            async runTest(test) {
                const testDiv = document.createElement('div');
                testDiv.className = 'test-case';

                const startTime = performance.now();
                let status = 'passed';
                let error = null;

                try {
                    await test.fn();
                } catch (e) {
                    status = 'failed';
                    error = e.message;
                    this.results.failed++;
                } finally {
                    if (status === 'passed') {
                        this.results.passed++;
                    }
                }

                const duration = Math.round(performance.now() - startTime);

                testDiv.className = `test-case ${status}`;
                testDiv.innerHTML = `
                    <span class="test-name">${test.name}</span>
                    <span class="test-duration">${duration}ms</span>
                    <span class="test-status status-${status}">${status === 'passed' ? '✓ PASS' : '✗ FAIL'}</span>
                `;

                if (error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'test-error';
                    errorDiv.textContent = error;
                    testDiv.appendChild(errorDiv);
                }

                return testDiv;
            }

            updateStats() {
                document.getElementById('totalTests').textContent = this.results.total;
                document.getElementById('passedTests').textContent = this.results.passed;
                document.getElementById('failedTests').textContent = this.results.failed;
                document.getElementById('skippedTests').textContent = this.results.skipped;

                const progress = this.results.total > 0 
                    ? (this.results.passed + this.results.failed) / this.results.total * 100 
                    : 0;
                document.getElementById('progressBar').style.width = progress + '%';
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Test Assertions
        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEqual(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(message || `Expected ${expected}, got ${actual}`);
            }
        }

        function assertNotEqual(actual, expected, message) {
            if (actual === expected) {
                throw new Error(message || `Expected values to be different`);
            }
        }

        async function assertThrows(fn, message) {
            let threw = false;
            try {
                await fn();
            } catch (e) {
                threw = true;
            }
            if (!threw) {
                throw new Error(message || 'Expected function to throw error');
            }
        }

        // Initialize Test Suite
        const suite = new TestSuite();

        // ========== PASSWORD HASHING TESTS ==========
        const passwordGroup = suite.group('Password Hashing & Security');

        passwordGroup.test('Should hash password using SHA-256', async () => {
            async function hashPassword(password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            const hash = await hashPassword('testpassword123');
            assertEqual(hash.length, 64, 'SHA-256 hash should be 64 characters');
        });

        passwordGroup.test('Same password should produce same hash', async () => {
            async function hashPassword(password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            const hash1 = await hashPassword('mypassword');
            const hash2 = await hashPassword('mypassword');
            assertEqual(hash1, hash2, 'Same password should produce same hash');
        });

        passwordGroup.test('Different passwords should produce different hashes', async () => {
            async function hashPassword(password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            const hash1 = await hashPassword('password1');
            const hash2 = await hashPassword('password2');
            assertNotEqual(hash1, hash2, 'Different passwords should produce different hashes');
        });

        passwordGroup.test('Password generator creates valid passwords', () => {
            function generatePassword() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
                let password = '';
                for (let i = 0; i < 12; i++) {
                    password += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return password;
            }

            const password = generatePassword();
            assertEqual(password.length, 12, 'Generated password should be 12 characters');
            assert(/^[A-Za-z0-9]+$/.test(password), 'Password should only contain alphanumeric characters');
        });

        // ========== USER MANAGEMENT TESTS ==========
        const userGroup = suite.group('User Management');

        userGroup.test('Should create user with all required fields', () => {
            const user = {
                name: 'Test User',
                email: 'test@example.com',
                passwordHash: 'hashed_password',
                role: 'Developer',
                country: 'TR',
                timezone: 'Europe/Istanbul',
                isAdmin: false,
                createdAt: new Date().toISOString()
            };

            assert(user.name, 'User should have name');
            assert(user.email, 'User should have email');
            assert(user.passwordHash, 'User should have password hash');
            assert(user.role, 'User should have role');
        });

        userGroup.test('Should validate email format', () => {
            function isValidEmail(email) {
                return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
            }

            assert(isValidEmail('test@example.com'), 'Should accept valid email');
            assert(!isValidEmail('invalid-email'), 'Should reject invalid email');
            assert(!isValidEmail('test@'), 'Should reject incomplete email');
        });

        userGroup.test('Should prevent duplicate emails', () => {
            const users = [
                { email: 'user1@test.com' },
                { email: 'user2@test.com' }
            ];

            const newEmail = 'user1@test.com';
            const isDuplicate = users.some(u => u.email.toLowerCase() === newEmail.toLowerCase());
            
            assert(isDuplicate, 'Should detect duplicate email');
        });

        userGroup.test('Should generate unique user IDs', () => {
            const id1 = Date.now();
            const id2 = Date.now() + 1;
            
            assertNotEqual(id1, id2, 'User IDs should be unique');
        });

        // ========== AVAILABILITY TESTS ==========
        const availabilityGroup = suite.group('Availability System');

        availabilityGroup.test('Should create availability entry for month', () => {
            const availability = {
                userId: '123456',
                monthKey: '2025-10',
                days: [1, 2, 5, 8, 9, 12]
            };

            assert(availability.monthKey, 'Should have month key');
            assert(Array.isArray(availability.days), 'Days should be array');
            assert(availability.days.length > 0, 'Should have at least one available day');
        });

        availabilityGroup.test('Should toggle day availability', () => {
            let days = [1, 2, 5];
            const day = 5;

            const index = days.indexOf(day);
            if (index > -1) {
                days.splice(index, 1);
            } else {
                days.push(day);
            }

            assert(!days.includes(5), 'Day 5 should be removed');
            assertEqual(days.length, 2, 'Should have 2 days remaining');
        });

        availabilityGroup.test('Should not allow weekend availability', () => {
            function isWeekend(year, month, day) {
                const date = new Date(year, month, day);
                const dayOfWeek = date.getDay();
                return dayOfWeek === 0 || dayOfWeek === 6;
            }

            assert(isWeekend(2025, 9, 5), 'Sunday should be weekend'); // Oct 5, 2025 is Sunday
            assert(isWeekend(2025, 9, 4), 'Saturday should be weekend'); // Oct 4, 2025 is Saturday
            assert(!isWeekend(2025, 9, 6), 'Monday should not be weekend');
        });

        availabilityGroup.test('Should format month key correctly', () => {
            const year = 2025;
            const month = 9; // October (0-indexed)
            const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
            
            assertEqual(monthKey, '2025-10', 'Month key should be formatted as YYYY-MM');
        });

        // ========== DATA VALIDATION TESTS ==========
        const validationGroup = suite.group('Data Validation');

        validationGroup.test('Should validate system data structure', () => {
            const systemData = {
                users: {},
                availability: {},
                config: {
                    company: 'Test Company',
                    initialized: true
                }
            };

            assert(systemData.users, 'Should have users object');
            assert(systemData.availability, 'Should have availability object');
            assert(systemData.config, 'Should have config object');
            assert(systemData.config.initialized, 'Config should be initialized');
        });

        validationGroup.test('Should validate GitHub config', () => {
            const config = {
                username: 'testuser',
                repo: 'team-data',
                token: 'ghp_test123',
                isConfigured: true
            };

            assert(config.username, 'Should have username');
            assert(config.repo, 'Should have repo');
            assert(config.token, 'Should have token');
            assert(config.isConfigured, 'Should be configured');
        });

        validationGroup.test('Should handle missing data gracefully', () => {
            const systemData = {};
            
            const users = systemData.users || {};
            const availability = systemData.availability || {};
            
            assert(typeof users === 'object', 'Should default to empty object for users');
            assert(typeof availability === 'object', 'Should default to empty object for availability');
        });

        // ========== CACHE TESTS ==========
        const cacheGroup = suite.group('Caching System');

        cacheGroup.test('Should cache data with timestamp', () => {
            const cache = {
                data: { test: 'data' },
                timestamp: Date.now(),
                ttl: 60000
            };

            assert(cache.data, 'Should have cached data');
            assert(cache.timestamp, 'Should have timestamp');
            assert(cache.ttl, 'Should have TTL');
        });

        cacheGroup.test('Should detect expired cache', () => {
            const cache = {
                data: { test: 'data' },
                timestamp: Date.now() - 120000, // 2 minutes ago
                ttl: 60000 // 1 minute TTL
            };

            const now = Date.now();
            const isExpired = (now - cache.timestamp) >= cache.ttl;
            
            assert(isExpired, 'Cache should be expired');
        });

        cacheGroup.test('Should detect valid cache', () => {
            const cache = {
                data: { test: 'data' },
                timestamp: Date.now(),
                ttl: 60000
            };

            const now = Date.now();
            const isValid = (now - cache.timestamp) < cache.ttl;
            
            assert(isValid, 'Cache should be valid');
        });

        // ========== UTILITY TESTS ==========
        const utilityGroup = suite.group('Utility Functions');

        utilityGroup.test('Should format date as ISO string', () => {
            const date = new Date('2025-10-01');
            const iso = date.toISOString();
            
            assert(iso.includes('2025'), 'ISO string should contain year');
            assert(iso.includes('T'), 'ISO string should contain time separator');
        });

        utilityGroup.test('Should generate random string', () => {
            function randomString(length) {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            const str = randomString(10);
            assertEqual(str.length, 10, 'Random string should have correct length');
        });

        utilityGroup.test('Should encode and decode JSON', () => {
            const data = { test: 'data', number: 123 };
            const json = JSON.stringify(data);
            const decoded = JSON.parse(json);
            
            assertEqual(decoded.test, 'data', 'Should decode correctly');
            assertEqual(decoded.number, 123, 'Should preserve number types');
        });

        // ========== PERFORMANCE TESTS ==========
        const perfGroup = suite.group('Performance');

        perfGroup.test('Password hashing should complete in < 100ms', async () => {
            async function hashPassword(password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            const start = performance.now();
            await hashPassword('test_password');
            const duration = performance.now() - start;
            
            assert(duration < 100, `Hashing took ${duration}ms, should be < 100ms`);
        });

        perfGroup.test('Array operations should be fast', () => {
            const arr = Array.from({ length: 1000 }, (_, i) => i);
            
            const start = performance.now();
            const filtered = arr.filter(x => x % 2 === 0);
            const duration = performance.now() - start;
            
            assert(duration < 10, `Array filtering took ${duration}ms, should be < 10ms`);
            assertEqual(filtered.length, 500, 'Should filter correctly');
        });

        // Functions
        async function runAllTests() {
            await suite.runAll();
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
            suite.results = { total: 0, passed: 0, failed: 0, skipped: 0 };
            suite.updateStats();
            document.getElementById('progressBar').style.width = '0%';
        }

        // Auto-run on load
        window.addEventListener('load', () => {
            setTimeout(runAllTests, 500);
        });
    </script>
</body>
</html>
